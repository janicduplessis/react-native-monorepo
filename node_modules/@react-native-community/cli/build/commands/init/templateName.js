"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processTemplateName = processTemplateName;

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _url() {
  const data = require("url");

  _url = function () {
    return data;
  };

  return data;
}

var _fetch = require("../../tools/fetch");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const FILE_PROTOCOL = /file:/;
const HTTP_PROTOCOL = /https?:/;

function handleFileProtocol(filePath) {
  const uri = new (_url().URL)(filePath).pathname;
  return {
    uri,
    name: require(_path().default.join(uri, 'package.json')).name
  };
}

async function processTemplateName(templateName) {
  if (templateName.match(FILE_PROTOCOL)) {
    return handleFileProtocol(templateName);
  }

  const name = await tryTemplateShorthand(templateName);
  return {
    uri: name,
    name
  };
}
/**
 * `init` may be invoked with a shorthand like `--template typescript`
 * which should resolve to `react-native-template-typescript` package.
 * To support that, we query npm registry if a package like this exists, if not
 * we return the original name without a change.
 */


async function tryTemplateShorthand(templateName) {
  if (templateName.match(FILE_PROTOCOL) || templateName.match(HTTP_PROTOCOL)) {
    return templateName;
  }

  try {
    const reactNativeTemplatePackage = `react-native-template-${templateName}`;
    const response = await (0, _fetch.fetch)(`https://registry.yarnpkg.com/${reactNativeTemplatePackage}/latest`);

    if (JSON.parse(response).name) {
      return reactNativeTemplatePackage;
    }
  } catch (e) {// we expect this to fail when `file://` protocol or regular module is passed
  }

  return templateName;
}