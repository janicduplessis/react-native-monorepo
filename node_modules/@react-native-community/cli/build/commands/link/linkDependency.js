"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _cliTools() {
  const data = require("@react-native-community/cli-tools");

  _cliTools = function () {
    return data;
  };

  return data;
}

var _pollParams = _interopRequireDefault(require("./pollParams"));

var _getPlatformName = _interopRequireDefault(require("./getPlatformName"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const linkDependency = async (platforms, project, dependency) => {
  const params = await (0, _pollParams.default)(dependency.params);
  Object.keys(platforms || {}).forEach(platform => {
    const projectConfig = project[platform];
    const dependencyConfig = dependency.platforms[platform];

    if (!projectConfig || !dependencyConfig) {
      return;
    }

    const {
      name
    } = dependency;
    const linkConfig = platforms[platform] && platforms[platform].linkConfig && platforms[platform].linkConfig();

    if (!linkConfig || !linkConfig.isInstalled || !linkConfig.register) {
      return;
    }

    const isInstalled = linkConfig.isInstalled( // $FlowFixMe
    projectConfig, name, // $FlowFixMe
    dependencyConfig);

    if (isInstalled) {
      _cliTools().logger.info(`${(0, _getPlatformName.default)(platform)} module "${name}" is already linked`);

      return;
    }

    _cliTools().logger.info(`Linking "${name}" ${(0, _getPlatformName.default)(platform)} dependency`); // $FlowFixMe


    linkConfig.register(name, dependencyConfig, params, projectConfig);

    _cliTools().logger.info(`${(0, _getPlatformName.default)(platform)} module "${dependency.name}" has been successfully linked`);
  });
};

var _default = linkDependency;
exports.default = _default;